# JPA ê³ ê¸‰ íŒ¨í„´ ë° ì‹¤ì „ ì˜ˆì œ

## message-service í™•ì¥ ì‹œë‚˜ë¦¬ì˜¤

---

## ğŸ“š ëª©ì°¨

1. [ì—°ê´€ê´€ê³„ ë§¤í•‘](#1-ì—°ê´€ê´€ê³„-ë§¤í•‘)
2. [Auditing](#2-auditing)
3. [Soft Delete](#3-soft-delete)
4. [Custom Repository](#4-custom-repository)
5. [Specificationìœ¼ë¡œ ë™ì  ì¿¼ë¦¬](#5-specificationìœ¼ë¡œ-ë™ì -ì¿¼ë¦¬)
6. [Pagination](#6-pagination)
7. [QueryDSL](#7-querydsl)
8. [ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§](#8-ì„±ëŠ¥-ëª¨ë‹ˆí„°ë§)

---

## 1. ì—°ê´€ê´€ê³„ ë§¤í•‘

### 1.1 @ManyToOne: Message â†’ User

í˜„ì¬ MessageëŠ” senderId, receiverIdë§Œ ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤. User Entityì™€ ì—°ê´€ê´€ê³„ë¥¼ ë§ºì–´ë´…ì‹œë‹¤.

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String email;
}

@Entity
@Table(name = "messages")
public class Message {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // âœ… ì—°ê´€ê´€ê³„ ë§¤í•‘
    @ManyToOne(fetch = FetchType.LAZY)  // ì§€ì—° ë¡œë”©
    @JoinColumn(name = "sender_id")      // FK ì»¬ëŸ¼ëª…
    private User sender;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "receiver_id")
    private User receiver;

    private String content;
    private boolean isRead;
    
    // ... ê¸°íƒ€ í•„ë“œ
}
```

**ì‚¬ìš© ì˜ˆì œ:**
```java
// ë©”ì‹œì§€ ìƒì„±
User sender = userRepository.findById(1L).get();
User receiver = userRepository.findById(2L).get();

Message message = new Message();
message.setSender(sender);      // User ê°ì²´ë¡œ ì„¤ì •
message.setReceiver(receiver);
message.setContent("Hello");

messageRepository.save(message);

// ë©”ì‹œì§€ ì¡°íšŒ
Message msg = messageRepository.findById(1L).get();
System.out.println(msg.getSender().getUsername());  // ë°œì‹ ì ì´ë¦„
System.out.println(msg.getReceiver().getEmail());   // ìˆ˜ì‹ ì ì´ë©”ì¼
```

**ìƒì„±ë˜ëŠ” SQL:**
```sql
CREATE TABLE messages (
    id BIGINT PRIMARY KEY,
    sender_id BIGINT,
    receiver_id BIGINT,
    content VARCHAR(500),
    FOREIGN KEY (sender_id) REFERENCES users(id),
    FOREIGN KEY (receiver_id) REFERENCES users(id)
);
```

### 1.2 FetchType ì´í•´í•˜ê¸°

#### LAZY (ì§€ì—° ë¡œë”©) âœ… ê¶Œì¥
```java
@ManyToOne(fetch = FetchType.LAZY)
private User sender;

// ì‚¬ìš© ì‹œì 
Message msg = messageRepository.findById(1L).get();  // SELECT messages
// senderëŠ” ì•„ì§ ì¡°íšŒ ì•ˆ ë¨

String name = msg.getSender().getUsername();  // ì´ ì‹œì ì— SELECT users
```

**ì¥ì :**
- í•„ìš”í•œ ì‹œì ì—ë§Œ ì¡°íšŒ
- ì„±ëŠ¥ ìµœì í™”

#### EAGER (ì¦‰ì‹œ ë¡œë”©) âŒ ë¹„ê¶Œì¥
```java
@ManyToOne(fetch = FetchType.EAGER)
private User sender;

// ì‚¬ìš© ì‹œì 
Message msg = messageRepository.findById(1L).get();  
// SELECT messages + SELECT users (ìë™ìœ¼ë¡œ JOIN)
```

**ë‹¨ì :**
- N+1 ë¬¸ì œ ë°œìƒ ê°€ëŠ¥
- ë¶ˆí•„ìš”í•œ ë°ì´í„°ê¹Œì§€ ì¡°íšŒ

### 1.3 @OneToMany: User â†’ Messages

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;

    // âœ… ì–‘ë°©í–¥ ë§¤í•‘
    @OneToMany(mappedBy = "sender", fetch = FetchType.LAZY)
    private List<Message> sentMessages = new ArrayList<>();

    @OneToMany(mappedBy = "receiver", fetch = FetchType.LAZY)
    private List<Message> receivedMessages = new ArrayList<>();
}
```

**ì‚¬ìš© ì˜ˆì œ:**
```java
User user = userRepository.findById(1L).get();

// ë³´ë‚¸ ë©”ì‹œì§€ ëª©ë¡
List<Message> sent = user.getSentMessages();

// ë°›ì€ ë©”ì‹œì§€ ëª©ë¡
List<Message> received = user.getReceivedMessages();
```

---

## 2. Auditing

### 2.1 JPA Auditing ì„¤ì •

ìƒì„±ì¼ì‹œ, ìˆ˜ì •ì¼ì‹œ, ìƒì„±ì, ìˆ˜ì •ìë¥¼ ìë™ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.

```java
@Configuration
@EnableJpaAuditing
public class JpaConfig {
    
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì •ë³´ ë°˜í™˜
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth == null || !auth.isAuthenticated()) {
                return Optional.of("system");
            }
            return Optional.of(auth.getName());
        };
    }
}
```

### 2.2 Base Entity íŒ¨í„´

```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
public abstract class BaseEntity {

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @CreatedBy
    @Column(nullable = false, updatable = false, length = 50)
    private String createdBy;

    @LastModifiedBy
    @Column(nullable = false, length = 50)
    private String updatedBy;
}
```

### 2.3 Message Entityì— ì ìš©

```java
@Entity
@Table(name = "messages")
public class Message extends BaseEntity {  // BaseEntity ìƒì†
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long senderId;
    private Long receiverId;
    private String content;
    private boolean isRead;
    
    // createdAt, updatedAt, createdBy, updatedByëŠ” ìë™ ê´€ë¦¬!
}
```

**ì‚¬ìš© ì˜ˆì œ:**
```java
Message message = new Message();
message.setContent("Hello");
messageRepository.save(message);

// ìë™ìœ¼ë¡œ ì„¤ì •ë¨:
// createdAt = 2024-01-15 10:30:00
// updatedAt = 2024-01-15 10:30:00
// createdBy = "user123"
// updatedBy = "user123"

// ìˆ˜ì • ì‹œ
message.setContent("Hi");
messageRepository.save(message);

// ìë™ ì—…ë°ì´íŠ¸:
// updatedAt = 2024-01-15 10:35:00
// updatedBy = "user123"
```

---

## 3. Soft Delete

### 3.1 Soft Deleteë€?

ì‹¤ì œ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì§€ ì•Šê³  ì‚­ì œ í”Œë˜ê·¸ë§Œ ì„¤ì •í•©ë‹ˆë‹¤.

```java
@Entity
@Table(name = "messages")
@SQLDelete(sql = "UPDATE messages SET deleted = true WHERE id = ?")  // DELETE ì‹œ ì‹¤í–‰
@Where(clause = "deleted = false")  // ì¡°íšŒ ì‹œ ìë™ í•„í„°ë§
public class Message {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long senderId;
    private Long receiverId;
    private String content;
    private boolean isRead;

    // âœ… Soft Delete í”Œë˜ê·¸
    @Column(nullable = false)
    private boolean deleted = false;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // âœ… ì‚­ì œì¼ì‹œ ì¶”ê°€
    private LocalDateTime deletedAt;
}
```

**ì‚¬ìš© ì˜ˆì œ:**
```java
// ì‚­ì œ
messageRepository.deleteById(1L);

// ì‹¤í–‰ë˜ëŠ” SQL:
// UPDATE messages SET deleted = true WHERE id = 1

// ì¡°íšŒ
List<Message> messages = messageRepository.findAll();
// ì‹¤í–‰ë˜ëŠ” SQL:
// SELECT * FROM messages WHERE deleted = false

// ì‚­ì œëœ ë©”ì‹œì§€ í¬í•¨ ì¡°íšŒ
@Query("SELECT m FROM Message m WHERE m.id = :id")
Optional<Message> findByIdIncludingDeleted(@Param("id") Long id);
```

### 3.2 Soft Deleteë¥¼ ìœ„í•œ Custom Repository

```java
public interface MessageRepository extends JpaRepository<Message, Long> {
    
    // ì¼ë°˜ ì¡°íšŒ (deleted = falseë§Œ)
    List<Message> findByReceiverId(Long receiverId);
    
    // ì‚­ì œëœ ê²ƒë§Œ ì¡°íšŒ
    @Query("SELECT m FROM Message m WHERE m.receiverId = :receiverId AND m.deleted = true")
    List<Message> findDeletedByReceiverId(@Param("receiverId") Long receiverId);
    
    // ì˜êµ¬ ì‚­ì œ
    @Modifying
    @Query("DELETE FROM Message m WHERE m.id = :id")
    void hardDelete(@Param("id") Long id);
}
```

---

## 4. Custom Repository

### 4.1 Custom Repository ì¸í„°í˜ì´ìŠ¤

```java
public interface MessageRepositoryCustom {
    List<Message> findMessagesWithComplexCondition(MessageSearchDto searchDto);
}
```

### 4.2 êµ¬í˜„ì²´

```java
@RequiredArgsConstructor
public class MessageRepositoryImpl implements MessageRepositoryCustom {

    private final EntityManager entityManager;

    @Override
    public List<Message> findMessagesWithComplexCondition(MessageSearchDto searchDto) {
        StringBuilder jpql = new StringBuilder("SELECT m FROM Message m WHERE 1=1");
        
        if (searchDto.getReceiverId() != null) {
            jpql.append(" AND m.receiverId = :receiverId");
        }
        
        if (searchDto.getKeyword() != null) {
            jpql.append(" AND m.content LIKE :keyword");
        }
        
        if (searchDto.isUnreadOnly()) {
            jpql.append(" AND m.isRead = false");
        }
        
        jpql.append(" ORDER BY m.createdAt DESC");
        
        TypedQuery<Message> query = entityManager.createQuery(jpql.toString(), Message.class);
        
        if (searchDto.getReceiverId() != null) {
            query.setParameter("receiverId", searchDto.getReceiverId());
        }
        
        if (searchDto.getKeyword() != null) {
            query.setParameter("keyword", "%" + searchDto.getKeyword() + "%");
        }
        
        return query.getResultList();
    }
}
```

### 4.3 ê¸°ë³¸ Repositoryì— í†µí•©

```java
public interface MessageRepository extends 
        JpaRepository<Message, Long>, 
        MessageRepositoryCustom {  // Custom ì¸í„°í˜ì´ìŠ¤ ì¶”ê°€
    
    // ê¸°ë³¸ ë©”ì„œë“œ
    List<Message> findByReceiverId(Long receiverId);
}
```

---

## 5. Specificationìœ¼ë¡œ ë™ì  ì¿¼ë¦¬

### 5.1 Specification ì„¤ì •

```java
public interface MessageRepository extends 
        JpaRepository<Message, Long>, 
        JpaSpecificationExecutor<Message> {  // Specification ì§€ì›
}
```

### 5.2 Specification ì‘ì„±

```java
public class MessageSpecification {

    public static Specification<Message> hasReceiverId(Long receiverId) {
        return (root, query, cb) -> 
            receiverId == null ? null : cb.equal(root.get("receiverId"), receiverId);
    }

    public static Specification<Message> hasSenderId(Long senderId) {
        return (root, query, cb) -> 
            senderId == null ? null : cb.equal(root.get("senderId"), senderId);
    }

    public static Specification<Message> isUnread() {
        return (root, query, cb) -> cb.equal(root.get("isRead"), false);
    }

    public static Specification<Message> contentContains(String keyword) {
        return (root, query, cb) -> 
            keyword == null ? null : cb.like(root.get("content"), "%" + keyword + "%");
    }

    public static Specification<Message> createdBetween(
            LocalDateTime start, LocalDateTime end) {
        return (root, query, cb) -> {
            if (start == null || end == null) return null;
            return cb.between(root.get("createdAt"), start, end);
        };
    }
}
```

### 5.3 ì‚¬ìš© ì˜ˆì œ

```java
@Service
@RequiredArgsConstructor
public class MessageService {

    private final MessageRepository messageRepository;

    public List<MessageResponseDto> searchMessages(MessageSearchDto searchDto) {
        // Specification ì¡°í•©
        Specification<Message> spec = Specification.where(null);
        
        if (searchDto.getReceiverId() != null) {
            spec = spec.and(MessageSpecification.hasReceiverId(searchDto.getReceiverId()));
        }
        
        if (searchDto.isUnreadOnly()) {
            spec = spec.and(MessageSpecification.isUnread());
        }
        
        if (searchDto.getKeyword() != null) {
            spec = spec.and(MessageSpecification.contentContains(searchDto.getKeyword()));
        }
        
        if (searchDto.getStartDate() != null && searchDto.getEndDate() != null) {
            spec = spec.and(MessageSpecification.createdBetween(
                searchDto.getStartDate(), searchDto.getEndDate()));
        }
        
        // ì‹¤í–‰
        List<Message> messages = messageRepository.findAll(spec);
        
        return messages.stream()
                .map(this::toDto)
                .toList();
    }
}
```

---

## 6. Pagination

### 6.1 ê¸°ë³¸ Pagination

```java
public interface MessageRepository extends JpaRepository<Message, Long> {
    
    // Pageable íŒŒë¼ë¯¸í„° ì¶”ê°€
    Page<Message> findByReceiverId(Long receiverId, Pageable pageable);
}
```

### 6.2 Serviceì—ì„œ ì‚¬ìš©

```java
@Service
@RequiredArgsConstructor
public class MessageService {

    private final MessageRepository messageRepository;

    public Page<MessageResponseDto> getMessages(Long receiverId, int page, int size) {
        // PageRequest ìƒì„±
        Pageable pageable = PageRequest.of(
            page,                              // í˜ì´ì§€ ë²ˆí˜¸ (0ë¶€í„° ì‹œì‘)
            size,                              // í˜ì´ì§€ í¬ê¸°
            Sort.by("createdAt").descending()  // ì •ë ¬
        );
        
        // í˜ì´ì§€ ì¡°íšŒ
        Page<Message> messagePage = messageRepository.findByReceiverId(receiverId, pageable);
        
        // DTO ë³€í™˜
        return messagePage.map(this::toDto);
    }
}
```

### 6.3 Controllerì—ì„œ ì‚¬ìš©

```java
@RestController
@RequestMapping("/messages")
@RequiredArgsConstructor
public class MessageController {

    private final MessageService messageService;

    @GetMapping("/inbox/{receiverId}")
    public ResponseEntity<Page<MessageResponseDto>> getInbox(
            @PathVariable Long receiverId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        Page<MessageResponseDto> messages = messageService.getMessages(receiverId, page, size);
        return ResponseEntity.ok(messages);
    }
}
```

**ì‘ë‹µ ì˜ˆì œ:**
```json
{
  "content": [
    {
      "id": 1,
      "senderId": 100,
      "receiverId": 200,
      "content": "Hello",
      "read": false,
      "createdAt": "2024-01-15T10:30:00"
    }
  ],
  "pageable": {
    "pageNumber": 0,
    "pageSize": 20
  },
  "totalElements": 45,
  "totalPages": 3,
  "first": true,
  "last": false,
  "size": 20,
  "number": 0
}
```

---

## 7. QueryDSL

### 7.1 ì˜ì¡´ì„± ì¶”ê°€

```gradle
dependencies {
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
}
```

### 7.2 Qí´ë˜ìŠ¤ ìƒì„±

ë¹Œë“œí•˜ë©´ ìë™ìœ¼ë¡œ `QMessage` í´ë˜ìŠ¤ ìƒì„±ë©ë‹ˆë‹¤.

### 7.3 QueryDSL Configuration

```java
@Configuration
public class QueryDslConfig {

    @PersistenceContext
    private EntityManager entityManager;

    @Bean
    public JPAQueryFactory jpaQueryFactory() {
        return new JPAQueryFactory(entityManager);
    }
}
```

### 7.4 Custom Repository êµ¬í˜„

```java
@Repository
@RequiredArgsConstructor
public class MessageQueryRepository {

    private final JPAQueryFactory queryFactory;

    public List<Message> searchMessages(MessageSearchDto searchDto) {
        QMessage message = QMessage.message;

        BooleanBuilder builder = new BooleanBuilder();

        // ì¡°ê±´ ì¶”ê°€
        if (searchDto.getReceiverId() != null) {
            builder.and(message.receiverId.eq(searchDto.getReceiverId()));
        }

        if (searchDto.isUnreadOnly()) {
            builder.and(message.isRead.isFalse());
        }

        if (searchDto.getKeyword() != null) {
            builder.and(message.content.contains(searchDto.getKeyword()));
        }

        if (searchDto.getStartDate() != null && searchDto.getEndDate() != null) {
            builder.and(message.createdAt.between(
                searchDto.getStartDate(), searchDto.getEndDate()));
        }

        // ì¿¼ë¦¬ ì‹¤í–‰
        return queryFactory
                .selectFrom(message)
                .where(builder)
                .orderBy(message.createdAt.desc())
                .fetch();
    }

    public long countUnreadMessages(Long receiverId) {
        QMessage message = QMessage.message;

        return queryFactory
                .selectFrom(message)
                .where(
                    message.receiverId.eq(receiverId)
                    .and(message.isRead.isFalse())
                )
                .fetchCount();
    }

    public List<MessageStatDto> getMessageStatsByUser() {
        QMessage message = QMessage.message;

        return queryFactory
                .select(Projections.constructor(
                    MessageStatDto.class,
                    message.receiverId,
                    message.count(),
                    message.isRead.when(false).then(1L).otherwise(0L).sum()
                ))
                .from(message)
                .groupBy(message.receiverId)
                .fetch();
    }
}
```

---

## 8. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### 8.1 P6Spy ì„¤ì •

SQL ë¡œê¹… ë° ì„±ëŠ¥ ë¶„ì„ ë„êµ¬

```gradle
dependencies {
    implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'
}
```

```yaml
# application.yml
decorator:
  datasource:
    p6spy:
      enable-logging: true
      multiline: true
      logging: slf4j
```

**ë¡œê·¸ ì¶œë ¥:**
```sql
2024-01-15 10:30:00 | 15 ms | SELECT * FROM messages WHERE receiver_id = 2 AND is_read = false ORDER BY created_at DESC
```

### 8.2 Hibernate Statistics

```yaml
spring:
  jpa:
    properties:
      hibernate:
        generate_statistics: true
        format_sql: true
```

```java
@Component
@RequiredArgsConstructor
public class HibernateStatisticsLogger {

    private final EntityManagerFactory entityManagerFactory;

    @Scheduled(fixedRate = 60000)  // 1ë¶„ë§ˆë‹¤
    public void logStatistics() {
        SessionFactory sessionFactory = entityManagerFactory.unwrap(SessionFactory.class);
        Statistics stats = sessionFactory.getStatistics();

        log.info("=== Hibernate Statistics ===");
        log.info("Queries executed: {}", stats.getQueryExecutionCount());
        log.info("Cache hit count: {}", stats.getSecondLevelCacheHitCount());
        log.info("Cache miss count: {}", stats.getSecondLevelCacheMissCount());
        log.info("Flush count: {}", stats.getFlushCount());
    }
}
```

---

## 9. ì‹¤ì „ ì˜ˆì œ ëª¨ìŒ

### 9.1 ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬

```java
@Service
@RequiredArgsConstructor
public class MessageBatchService {

    private final MessageRepository messageRepository;
    private final EntityManager entityManager;

    @Transactional
    public void bulkInsert(List<MessageCreateDto> dtos) {
        int batchSize = 100;
        
        for (int i = 0; i < dtos.size(); i++) {
            Message message = convertToEntity(dtos.get(i));
            entityManager.persist(message);
            
            if (i % batchSize == 0 && i > 0) {
                entityManager.flush();
                entityManager.clear();
            }
        }
    }

    @Transactional
    public void bulkUpdate(List<Long> messageIds, boolean isRead) {
        messageRepository.bulkUpdateReadStatus(messageIds, isRead);
    }
}

// Repository
public interface MessageRepository extends JpaRepository<Message, Long> {
    
    @Modifying
    @Query("UPDATE Message m SET m.isRead = :isRead WHERE m.id IN :ids")
    void bulkUpdateReadStatus(@Param("ids") List<Long> ids, @Param("isRead") boolean isRead);
}
```

### 9.2 ì½ê¸° ì „ìš© ìµœì í™”

```java
@Service
@RequiredArgsConstructor
public class MessageQueryService {

    private final EntityManager entityManager;

    @Transactional(readOnly = true)
    public List<MessageSummaryDto> getMessageSummaries(Long receiverId) {
        // DTO ì§ì ‘ ì¡°íšŒ (Entityë¥¼ ê±°ì¹˜ì§€ ì•ŠìŒ)
        return entityManager.createQuery(
            "SELECT new com.example.dto.MessageSummaryDto(" +
            "m.id, m.senderId, m.content, m.createdAt) " +
            "FROM Message m " +
            "WHERE m.receiverId = :receiverId " +
            "ORDER BY m.createdAt DESC",
            MessageSummaryDto.class
        )
        .setParameter("receiverId", receiverId)
        .setHint("org.hibernate.readOnly", true)  // ì½ê¸° ì „ìš© íŒíŠ¸
        .getResultList();
    }
}
```

---

## 10. ìš”ì•½

### ê³ ê¸‰ JPA ê¸°ëŠ¥ í™œìš©

| ê¸°ëŠ¥ | ìš©ë„ | ì¶”ì²œ ìƒí™© |
|------|------|-----------|
| ì—°ê´€ê´€ê³„ | Entity ê°„ ê´€ê³„ í‘œí˜„ | ê°ì²´ì§€í–¥ì  ì„¤ê³„ |
| Auditing | ìƒì„±/ìˆ˜ì • ì •ë³´ ìë™ ê´€ë¦¬ | ëª¨ë“  í”„ë¡œì íŠ¸ |
| Soft Delete | ë…¼ë¦¬ ì‚­ì œ | ë°ì´í„° ë³µêµ¬ í•„ìš” ì‹œ |
| Specification | ë™ì  ì¿¼ë¦¬ | ë³µì¡í•œ ê²€ìƒ‰ ì¡°ê±´ |
| Pagination | í˜ì´ì§• ì²˜ë¦¬ | ëŒ€ëŸ‰ ë°ì´í„° ì¡°íšŒ |
| QueryDSL | íƒ€ì… ì•ˆì „ ì¿¼ë¦¬ | ë³µì¡í•œ ì¿¼ë¦¬ ë§ì„ ë•Œ |

### ì„±ëŠ¥ ìµœì í™” íŒ

1. **LAZY Loading ê¸°ë³¸ ì‚¬ìš©**
2. **Batch Size ì„¤ì •**
3. **ì¸ë±ìŠ¤ ì ì ˆíˆ í™œìš©**
4. **ë¶ˆí•„ìš”í•œ í•„ë“œ ì¡°íšŒ ìµœì†Œí™”**
5. **ëŒ€ëŸ‰ ì‘ì—… ì‹œ Batch ì²˜ë¦¬**
6. **ì½ê¸° ì „ìš© íŠ¸ëœì­ì…˜ í™œìš©**
7. **N+1 ë¬¸ì œ ì£¼ì˜**
8. **ìºì‹œ ì ê·¹ í™œìš©**
